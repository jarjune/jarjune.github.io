<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.jarjune.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="java内存区域运行时数据区域 程序计数器  程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计">
<meta property="og:type" content="article">
<meta property="og:title" content="【阅读笔记】深入java虚拟机重要内容">
<meta property="og:url" content="https://blog.jarjune.com/2021/02/12/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E6%B7%B1%E5%85%A5java%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%87%8D%E8%A6%81%E5%86%85%E5%AE%B9/index.html">
<meta property="og:site_name" content="前端的java">
<meta property="og:description" content="java内存区域运行时数据区域 程序计数器  程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.jarjune.com/pic/image-20210212115328670.png">
<meta property="og:image" content="https://blog.jarjune.com/pic/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png">
<meta property="og:image" content="https://blog.jarjune.com/pic/%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="https://blog.jarjune.com/pic/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="https://blog.jarjune.com/pic/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="https://blog.jarjune.com/pic/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="https://blog.jarjune.com/pic/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png">
<meta property="og:image" content="https://blog.jarjune.com/pic/Serial%E6%94%B6%E9%9B%86%E5%99%A8.png">
<meta property="og:image" content="https://blog.jarjune.com/pic/ParNew%E6%94%B6%E9%9B%86%E5%99%A8.png">
<meta property="og:image" content="https://blog.jarjune.com/pic/Parallel%E6%94%B6%E9%9B%86%E5%99%A8.png">
<meta property="og:image" content="https://blog.jarjune.com/pic/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png">
<meta property="og:image" content="https://blog.jarjune.com/pic/G1%E6%94%B6%E9%9B%86%E5%99%A8.png">
<meta property="og:image" content="https://blog.jarjune.com/pic/%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B01.png">
<meta property="og:image" content="https://blog.jarjune.com/pic/%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B02.png">
<meta property="og:image" content="https://blog.jarjune.com/pic/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png">
<meta property="article:published_time" content="2021-02-12T03:51:11.000Z">
<meta property="article:modified_time" content="2021-05-20T02:55:52.093Z">
<meta property="article:author" content="jarjune">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.jarjune.com/pic/image-20210212115328670.png">

<link rel="canonical" href="https://blog.jarjune.com/2021/02/12/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E6%B7%B1%E5%85%A5java%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%87%8D%E8%A6%81%E5%86%85%E5%AE%B9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>【阅读笔记】深入java虚拟机重要内容 | 前端的java</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">前端的java</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.jarjune.com/2021/02/12/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E6%B7%B1%E5%85%A5java%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%87%8D%E8%A6%81%E5%86%85%E5%AE%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jarjune">
      <meta itemprop="description" content="java的前端">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端的java">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【阅读笔记】深入java虚拟机重要内容
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-12 11:51:11" itemprop="dateCreated datePublished" datetime="2021-02-12T11:51:11+08:00">2021-02-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-20 10:55:52" itemprop="dateModified" datetime="2021-05-20T10:55:52+08:00">2021-05-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="java内存区域"><a href="#java内存区域" class="headerlink" title="java内存区域"></a>java内存区域</h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p><img src="https://blog.jarjune.com/pic/image-20210212115328670.png" alt="image-20210212115328670"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><blockquote>
<p> 程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线<br>程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能<br>会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选<br>取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需<br>要依赖这个计数器来完成。</p>
<p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，<br>在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线<br>程中的指令。因此，为了线程切换后能恢复到正确的执行位置，<strong>每条线程都需要有一个独立<br>的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私<br>有”的内存。</strong></p>
<p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指<br>令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。此内存区域<br>是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
</blockquote>
<h3 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h3><blockquote>
<p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的<br>生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时<br>都会创建一个栈帧（Stack Frame[1]）用于存储局部变量表、操作数栈、动态链接、方法出口<br>等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出<br>栈的过程。<br>经常有人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗<br>糙，Java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最<br>关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”笔者在后面会专<br>门讲述，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中局部变量表部分。<br>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、<br>float、long、double）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对<br>象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和<br>returnAddress类型（指向了一条字节码指令的地址）。<br>其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据<br>类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这<br>个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变<br>量表的大小。<br>在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚<br>拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部<br>分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如<br>果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p>
</blockquote>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><blockquote>
<p>本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间<br>的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚<br>拟机使用到的Native方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式<br>与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如<br>Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法<br>栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p>
</blockquote>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><blockquote>
<p>对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。<br>Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就<br>是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描<br>述是：所有的对象实例以及数组都要在堆上分配[1]，但是随着JIT编译器的发展与逃逸分析技<br>术逐渐成熟，栈上分配、标量替换[2]优化技术将会导致一些微妙的变化发生，所有的对象都<br>分配在堆上也渐渐变得不是那么“绝对”了。<br>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”（Garbage<br>Collected Heap，幸好国内没翻译成“垃圾堆”）。从内存回收的角度来看，由于现在收集器基<br>本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有<br>Eden空间、From Survivor空间、To Survivor空间等。从内存分配的角度来看，线程共享的<br>Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）。不<br>过无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划<br>分的目的是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域<br>的作用进行讨论，Java堆中的上述各个区域的分配、回收等细节将是第3章的主题。<br>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上<br>是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是<br>可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如<br>果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异<br>常。</p>
</blockquote>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><blockquote>
<p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚<br>拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规<br>范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应<br>该是与Java堆区分开来。<br>对于习惯在HotSpot虚拟机上开发、部署程序的开发者来说，很多人都更愿意把方法区<br>称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的<br>设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已，这样<br>HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省去专门为方法区编写内<br>存管理代码的工作。对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概<br>念的。原则上，如何实现方法区属于虚拟机实现细节，不受虚拟机规范约束，但使用永久代<br>来实现方法区，现在看来并不是一个好主意，因为这样更容易遇到内存溢出问题（永久代<br>有-XX：MaxPermSize的上限，J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系<br>统中的4GB，就不会出现问题），而且有极少数方法（例如String.intern（））会因这个原因<br>导致不同虚拟机下有不同的表现。因此，对于HotSpot虚拟机，根据官方发布的路线图信<br>息，现在也有放弃永久代并逐步改为采用Native Memory来实现方法区的规划了[1]，在目前已<br>经发布的JDK 1.7的HotSpot中，已经把原本放在永久代的字符串常量池移出。<br>Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以<br>选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个<br>区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区<br>域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说，这个区域的回<br>收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确<br>实是必要的。在Sun公司的BUG列表中，曾出现过的若干个严重的BUG就是由于低版本的<br>HotSpot虚拟机对此区域未完全回收而导致内存泄漏。<br>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出<br>OutOfMemoryError异常。</p>
</blockquote>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><blockquote>
<p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版<br>本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于<br>存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常<br>量池中存放。<br>Java虚拟机对Class文件每一部分（自然也包括常量池）的格式都有严格规定，每一个字<br>节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行，但对于运行<br>时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自<br>己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，<br>还会把翻译出来的直接引用也存储在运行时常量池中[1]。<br>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不<br>要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方<br>法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较<br>多的便是String类的intern（）方法。<br>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申<br>请到内存时会抛出OutOfMemoryError异常。</p>
</blockquote>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><blockquote>
<p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规<br>范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError<br>异常出现，所以我们放到这里一起讲解。<br>在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓<br>冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储<br>在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著<br>提高性能，因为避免了在Java堆和Native堆中来回复制数据。<br>显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是<br>会受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限<br>制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略<br>直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），<br>从而导致动态扩展时出现OutOfMemoryError异常。</p>
</blockquote>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><blockquote>
<p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、<br>实例数据（Instance Data）和对齐填充（Padding）。<br>HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，<br>如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时<br>间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和<br>64bit，官方称它为“Mark Word”。对象需要存储的运行时数据很多，其实已经超出了32位、<br>64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储<br>成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的<br>空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如，在32位的<br>HotSpot虚拟机中，如果对象处于未被锁定的状态下，那么Mark Word的32bit空间中的25bit用<br>于存储对象哈希码，4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0，而在<br>其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容见表2-1。</p>
</blockquote>
<p><img src="https://blog.jarjune.com/pic/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" alt="image-20210222132534618"></p>
<blockquote>
<p>对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。<br>由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，<br>就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或者2倍），<br>因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
</blockquote>
<h2 id="垃圾收集器（gc）"><a href="#垃圾收集器（gc）" class="headerlink" title="垃圾收集器（gc）"></a>垃圾收集器（gc）</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><blockquote>
<p> 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的，但是循环引用就不适合用引用计数算法</p>
</blockquote>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><blockquote>
<p>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p>
</blockquote>
<p><img src="https://blog.jarjune.com/pic/%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%AE%97%E6%B3%95.png" alt="image-20210222133436053"></p>
<p>在Java语言中，可作为GC Roots的对象包括下面几种：</p>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li>
</ol>
<h2 id="4种引用类型"><a href="#4种引用类型" class="headerlink" title="4种引用类型"></a>4种引用类型</h2><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>就是指在程序代码之中普遍存在的，类似“Object obj=new Object（）”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p>
<h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。</p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。</p>
<h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><blockquote>
<p>最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
</blockquote>
<p><img src="https://blog.jarjune.com/pic/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt="image-20210222134052798"></p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><blockquote>
<p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。</p>
</blockquote>
<p><img src="https://blog.jarjune.com/pic/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="image-20210222134150989"></p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><blockquote>
<p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p>
</blockquote>
<p><img src="https://blog.jarjune.com/pic/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt="image-20210222134309114"></p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><blockquote>
<p>根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p>
</blockquote>
<h2 id="垃圾收集器类型"><a href="#垃圾收集器类型" class="headerlink" title="垃圾收集器类型"></a>垃圾收集器类型</h2><p><img src="https://blog.jarjune.com/pic/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="image-20210222134656360"></p>
<h3 id="Serial收集器-Serial-Old收集器"><a href="#Serial收集器-Serial-Old收集器" class="headerlink" title="Serial收集器/Serial Old收集器"></a>Serial收集器/Serial Old收集器</h3><p><img src="https://blog.jarjune.com/pic/Serial%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="image-20210222134735412"></p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p><img src="https://blog.jarjune.com/pic/ParNew%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="image-20210222134919886"></p>
<h3 id="Parallel-Scavenge收集器（复制算法）-Parallel-Old（标记整理算法）收集器"><a href="#Parallel-Scavenge收集器（复制算法）-Parallel-Old（标记整理算法）收集器" class="headerlink" title="Parallel Scavenge收集器（复制算法）/Parallel Old（标记整理算法）收集器"></a>Parallel Scavenge收集器（复制算法）/Parallel Old（标记整理算法）收集器</h3><p><img src="https://blog.jarjune.com/pic/Parallel%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="image-20210222135348192"></p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p><img src="https://blog.jarjune.com/pic/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="image-20210222135904806"></p>
<ol>
<li>初始标记（CMS initial mark）需要Stop The World</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）需要Stop The World</li>
<li>并发清除（CMS concurrent sweep）</li>
</ol>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><ol>
<li>初始标记（Initial Marking）</li>
<li>并发标记（Concurrent Marking）</li>
<li>最终标记（Final Marking）</li>
<li>筛选回收（Live Data Counting and Evacuation）</li>
</ol>
<p><img src="https://blog.jarjune.com/pic/G1%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="image-20210222140117091"></p>
<h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><p><img src="https://blog.jarjune.com/pic/%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B01.png" alt="image-20210222140336659"></p>
<p><img src="https://blog.jarjune.com/pic/%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B02.png" alt="image-20210222140441293"></p>
<h1 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h1><p><img src="https://blog.jarjune.com/pic/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="image-20210222131359444"></p>
<h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><blockquote>
<p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内<br>存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来<br>完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double<br>和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外</p>
</blockquote>
<blockquote>
<p><strong>lock</strong>（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。<br><strong>unlock</strong>（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放<br>后的变量才可以被其他线程锁定。<br><strong>read</strong>（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内<br>存中，以便随后的load动作使用。<br><strong>load</strong>（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工<br>作内存的变量副本中。<br><strong>use</strong>（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引<br>擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。<br><strong>assign</strong>（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内<br>存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。<br><strong>store</strong>（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存<br>中，以便随后的write操作使用。<br><strong>write</strong>（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入<br>主内存的变量中。</p>
</blockquote>
<blockquote>
<p>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了<br>但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。<br>不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该<br>变化同步回主内存。<br>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步<br>回主内存中。<br>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化<br>（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行<br>过了assign和load操作。<br>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线<br>程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。<br>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这<br>个变量前，需要重新执行load或assign操作初始化变量的值。<br>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去<br>unlock一个被其他线程锁定住的变量。<br>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操<br>作）</p>
</blockquote>
<h1 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h1><p>源自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/andy-zhou/p/5327288.html">https://www.cnblogs.com/andy-zhou/p/5327288.html</a></p>
<h3 id="堆大小设置"><a href="#堆大小设置" class="headerlink" title="堆大小设置"></a>堆大小设置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx3550m -Xms3550m -Xmn2g –Xss128k</span><br><span class="line"></span><br><span class="line">-Xmx3550m：设置JVM最大可用内存为3550M。</span><br><span class="line"></span><br><span class="line">-Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</span><br><span class="line"></span><br><span class="line">-Xmn2g：设置年轻代大小为2G。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</span><br><span class="line"></span><br><span class="line">-Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0</span><br><span class="line"></span><br><span class="line">-XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5</span><br><span class="line"></span><br><span class="line">-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6</span><br><span class="line"></span><br><span class="line">-XX:MaxPermSize=16m:设置持久代大小为16m。</span><br><span class="line"></span><br><span class="line">-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</span><br></pre></td></tr></table></figure>

<h3 id="回收器选择"><a href="#回收器选择" class="headerlink" title="回收器选择"></a>回收器选择</h3><h4 id="吞吐量优先的并行收集器"><a href="#吞吐量优先的并行收集器" class="headerlink" title="吞吐量优先的并行收集器"></a>吞吐量优先的并行收集器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20</span><br><span class="line"></span><br><span class="line">-XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。</span><br><span class="line"></span><br><span class="line">-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 -XX:+UseParallelOldGC</span><br><span class="line"></span><br><span class="line">-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis=100</span><br><span class="line"></span><br><span class="line">-XX:MaxGCPauseMillis=100:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis=100 -XX:+UseAdaptiveSizePolicy</span><br><span class="line"></span><br><span class="line">-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。</span><br></pre></td></tr></table></figure>

<h4 id="响应时间优先的并发收集器"><a href="#响应时间优先的并发收集器" class="headerlink" title="响应时间优先的并发收集器"></a>响应时间优先的并发收集器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC</span><br><span class="line"></span><br><span class="line">-XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。</span><br><span class="line"></span><br><span class="line">-XX:+UseParNewGC: 设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection</span><br><span class="line"></span><br><span class="line">-XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。</span><br><span class="line"></span><br><span class="line">-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片</span><br></pre></td></tr></table></figure>

<h4 id="辅助信息"><a href="#辅助信息" class="headerlink" title="辅助信息"></a>辅助信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGC：输出形式：[GC 118250K-&gt;113543K(130112K), 0.0094143 secs] [Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs]</span><br><span class="line"></span><br><span class="line">-XX:+PrintGCDetails：输出形式：[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs] [GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs]</span><br><span class="line"></span><br><span class="line">-XX:+PrintGCTimeStamps -XX:+PrintGC：PrintGCTimeStamps可与上面两个混合使用</span><br><span class="line">输出形式：11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs]</span><br><span class="line"></span><br><span class="line">-XX:+PrintGCApplicationConcurrentTime：打印每次垃圾回收前，程序未中断的执行时间。可与上面混合使用。输出形式：Application time: 0.5291524 seconds</span><br><span class="line"></span><br><span class="line">-XX:+PrintGCApplicationStoppedTime：打印垃圾回收期间程序暂停的时间。可与上面混合使用。输出形式：Total time for which application threads were stopped: 0.0468229 seconds</span><br><span class="line"></span><br><span class="line">-XX:PrintHeapAtGC: 打印GC前后的详细堆栈信息。输出形式：</span><br><span class="line"></span><br><span class="line">34.702: [GC &#123;Heap before gc invocations=7:</span><br><span class="line">def new generation total 55296K, used 52568K [0x1ebd0000, 0x227d0000, 0x227d0000)</span><br><span class="line">eden space 49152K, 99% used [0x1ebd0000, 0x21bce430, 0x21bd0000)</span><br><span class="line">from space 6144K, 55% used [0x221d0000, 0x22527e10, 0x227d0000)</span><br><span class="line">to space 6144K, 0% used [0x21bd0000, 0x21bd0000, 0x221d0000)</span><br><span class="line">tenured generation total 69632K, used 2696K [0x227d0000, 0x26bd0000, 0x26bd0000)</span><br><span class="line">the space 69632K, 3% used [0x227d0000, 0x22a720f8, 0x22a72200, 0x26bd0000)</span><br><span class="line">compacting perm gen total 8192K, used 2898K [0x26bd0000, 0x273d0000, 0x2abd0000)</span><br><span class="line">the space 8192K, 35% used [0x26bd0000, 0x26ea4ba8, 0x26ea4c00, 0x273d0000)</span><br><span class="line">ro space 8192K, 66% used [0x2abd0000, 0x2b12bcc0, 0x2b12be00, 0x2b3d0000)</span><br><span class="line">rw space 12288K, 46% used [0x2b3d0000, 0x2b972060, 0x2b972200, 0x2bfd0000)</span><br><span class="line">34.735: [DefNew: 52568K-&gt;3433K(55296K), 0.0072126 secs] 55264K-&gt;6615K(124928K)Heap after gc invocations=8:</span><br><span class="line">def new generation total 55296K, used 3433K [0x1ebd0000, 0x227d0000, 0x227d0000)</span><br><span class="line">eden space 49152K, 0% used [0x1ebd0000, 0x1ebd0000, 0x21bd0000)</span><br><span class="line">from space 6144K, 55% used [0x21bd0000, 0x21f2a5e8, 0x221d0000)</span><br><span class="line">to space 6144K, 0% used [0x221d0000, 0x221d0000, 0x227d0000)</span><br><span class="line">tenured generation total 69632K, used 3182K [0x227d0000, 0x26bd0000, 0x26bd0000)</span><br><span class="line">the space 69632K, 4% used [0x227d0000, 0x22aeb958, 0x22aeba00, 0x26bd0000)</span><br><span class="line">compacting perm gen total 8192K, used 2898K [0x26bd0000, 0x273d0000, 0x2abd0000)</span><br><span class="line">the space 8192K, 35% used [0x26bd0000, 0x26ea4ba8, 0x26ea4c00, 0x273d0000)</span><br><span class="line">ro space 8192K, 66% used [0x2abd0000, 0x2b12bcc0, 0x2b12be00, 0x2b3d0000)</span><br><span class="line">rw space 12288K, 46% used [0x2b3d0000, 0x2b972060, 0x2b972200, 0x2bfd0000)</span><br><span class="line">&#125;</span><br><span class="line">, 0.0757599 secs]</span><br><span class="line"></span><br><span class="line">-Xloggc:filename:与上面几个配合使用，把相关日志信息记录到文件以便分析。</span><br></pre></td></tr></table></figure>

<h3 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">堆设置</span><br><span class="line">-Xms:初始堆大小</span><br><span class="line">-Xmx:最大堆大小</span><br><span class="line">-XX:NewSize=n:设置年轻代大小</span><br><span class="line">-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4</span><br><span class="line">-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5</span><br><span class="line">-XX:MaxPermSize=n:设置持久代大小</span><br><span class="line"></span><br><span class="line">收集器设置</span><br><span class="line">-XX:+UseSerialGC:设置串行收集器</span><br><span class="line">-XX:+UseParallelGC:设置并行收集器</span><br><span class="line">-XX:+UseParalledlOldGC:设置并行年老代收集器</span><br><span class="line">-XX:+UseConcMarkSweepGC:设置并发收集器</span><br><span class="line"></span><br><span class="line">垃圾回收统计信息</span><br><span class="line">-XX:+PrintGC</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCTimeStamps</span><br><span class="line">-Xloggc:filename</span><br><span class="line"></span><br><span class="line">并行收集器设置</span><br><span class="line">-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。</span><br><span class="line">-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间</span><br><span class="line">-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</span><br><span class="line"></span><br><span class="line">并发收集器设置</span><br><span class="line">-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。</span><br><span class="line">-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</span><br></pre></td></tr></table></figure>



<p>突然找到一篇好文</p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000022640316">https://segmentfault.com/a/1190000022640316</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/02/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%E3%80%81%E5%AE%9E%E4%BE%8B%E3%80%81%E5%AE%9E%E6%88%98/" rel="prev" title="设计模式解析、实例、实战">
      <i class="fa fa-chevron-left"></i> 设计模式解析、实例、实战
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/02/18/synchronized%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" rel="next" title="synchronized原理解析">
      synchronized原理解析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="nav-number">1.</span> <span class="nav-text">java内存区域</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F"><span class="nav-number">1.1.</span> <span class="nav-text">运行时数据区域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">1.1.1.</span> <span class="nav-text">程序计数器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-number">1.1.2.</span> <span class="nav-text">java虚拟机栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="nav-number">1.1.3.</span> <span class="nav-text">本地方法栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%A0%86"><span class="nav-number">1.1.4.</span> <span class="nav-text">Java堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">1.1.5.</span> <span class="nav-text">方法区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">1.1.6.</span> <span class="nav-text">运行时常量池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="nav-number">1.1.7.</span> <span class="nav-text">直接内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">1.1.8.</span> <span class="nav-text">对象的内存布局</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88gc%EF%BC%89"><span class="nav-number">1.2.</span> <span class="nav-text">垃圾收集器（gc）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.1.</span> <span class="nav-text">引用计数算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.2.</span> <span class="nav-text">可达性分析算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.</span> <span class="nav-text">4种引用类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="nav-number">1.3.1.</span> <span class="nav-text">强引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="nav-number">1.3.2.</span> <span class="nav-text">软引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="nav-number">1.3.3.</span> <span class="nav-text">弱引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8"><span class="nav-number">1.3.4.</span> <span class="nav-text">虚引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.</span> <span class="nav-text">垃圾收集算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.1.</span> <span class="nav-text">标记-清除算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.2.</span> <span class="nav-text">复制算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.3.</span> <span class="nav-text">标记-整理算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.4.</span> <span class="nav-text">分代收集算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.5.</span> <span class="nav-text">垃圾收集器类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Serial%E6%94%B6%E9%9B%86%E5%99%A8-Serial-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.5.1.</span> <span class="nav-text">Serial收集器&#x2F;Serial Old收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ParNew%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.5.2.</span> <span class="nav-text">ParNew收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parallel-Scavenge%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95%EF%BC%89-Parallel-Old%EF%BC%88%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%EF%BC%89%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.5.3.</span> <span class="nav-text">Parallel Scavenge收集器（复制算法）&#x2F;Parallel Old（标记整理算法）收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CMS%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.5.4.</span> <span class="nav-text">CMS收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.5.5.</span> <span class="nav-text">G1收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0"><span class="nav-number">1.5.6.</span> <span class="nav-text">常用参数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">java内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E9%97%B4%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C"><span class="nav-number">2.1.</span> <span class="nav-text">内存间交互操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BE%E4%B8%AA%E6%A0%97%E5%AD%90"><span class="nav-number">3.</span> <span class="nav-text">举个栗子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E5%A4%A7%E5%B0%8F%E8%AE%BE%E7%BD%AE"><span class="nav-number">3.0.1.</span> <span class="nav-text">堆大小设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E5%99%A8%E9%80%89%E6%8B%A9"><span class="nav-number">3.0.2.</span> <span class="nav-text">回收器选择</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88%E7%9A%84%E5%B9%B6%E8%A1%8C%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">3.0.2.1.</span> <span class="nav-text">吞吐量优先的并行收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E7%9A%84%E5%B9%B6%E5%8F%91%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">3.0.2.2.</span> <span class="nav-text">响应时间优先的并发收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%85%E5%8A%A9%E4%BF%A1%E6%81%AF"><span class="nav-number">3.0.2.3.</span> <span class="nav-text">辅助信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE"><span class="nav-number">3.0.3.</span> <span class="nav-text">常见配置</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">jarjune</p>
  <div class="site-description" itemprop="description">java的前端</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jarjune</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
